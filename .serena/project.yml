# list of languages for which language servers are started; choose from:
#   al               bash             clojure          cpp              csharp           csharp_omnisharp
#   dart             elixir           elm              erlang           fortran          go
#   haskell          java             julia            kotlin           lua              markdown
#   nix              perl             php              python           python_jedi      r
#   rego             ruby             ruby_solargraph  rust             scala            swift
#   terraform        typescript       typescript_vts   yaml             zig
# Note:
#   - For C, use cpp
#   - For JavaScript, use typescript
# Special requirements:
#   - csharp: Requires the presence of a .sln file in the project folder.
# When using multiple languages, the first language server that supports a given file will be used for that file.
# The first language is the default language and the respective language server will be used as a fallback.
# Note that when using the JetBrains backend, language servers are not used and this list is correspondingly ignored.
languages:
- typescript

# the encoding used by text files in the project
# For a list of possible encodings, see https://docs.python.org/3.11/library/codecs.html#standard-encodings
encoding: "utf-8"

# whether to use the project's gitignore file to ignore files
# Added on 2025-04-07
ignore_all_files_in_gitignore: true

# list of additional paths to ignore
# same syntax as gitignore, so you can use * and **
# Was previously called `ignored_dirs`, please update your config if you are using that.
# Added (renamed) on 2025-04-07
ignored_paths: []

# whether the project is in read-only mode
# If set to true, all editing tools will be disabled and attempts to use them will result in an error
# Added on 2025-04-18
read_only: false

# list of tool names to exclude. We recommend not excluding any tools, see the readme for more details.
# Below is the complete list of tools for convenience.
# To make sure you have the latest list of tools, and to view their descriptions,
# execute `uv run scripts/print_tool_overview.py`.
#
#  * `activate_project`: Activates a project by name.
#  * `check_onboarding_performed`: Checks whether project onboarding was already performed.
#  * `create_text_file`: Creates/overwrites a file in the project directory.
#  * `delete_lines`: Deletes a range of lines within a file.
#  * `delete_memory`: Deletes a memory from Serena's project-specific memory store.
#  * `execute_shell_command`: Executes a shell command.
#  * `find_referencing_code_snippets`: Finds code snippets in which the symbol at the given location is referenced.
#  * `find_referencing_symbols`: Finds symbols that reference the symbol at the given location (optionally filtered by type).
#  * `find_symbol`: Performs a global (or local) search for symbols with/containing a given name/substring (optionally filtered by type).
#  * `get_current_config`: Prints the current configuration of the agent, including the active and available projects, tools, contexts, and modes.
#  * `get_symbols_overview`: Gets an overview of the top-level symbols defined in a given file.
#  * `initial_instructions`: Gets the initial instructions for the current project.
#     Should only be used in settings where the system prompt cannot be set,
#     e.g. in clients you have no control over, like Claude Desktop.
#  * `insert_after_symbol`: Inserts content after the end of the definition of a given symbol.
#  * `insert_at_line`: Inserts content at a given line in a file.
#  * `insert_before_symbol`: Inserts content before the beginning of the definition of a given symbol.
#  * `list_dir`: Lists files and directories in the given directory (optionally with recursion).
#  * `list_memories`: Lists memories in Serena's project-specific memory store.
#  * `onboarding`: Performs onboarding (identifying the project structure and essential tasks, e.g. for testing or building).
#  * `prepare_for_new_conversation`: Provides instructions for preparing for a new conversation (in order to continue with the necessary context).
#  * `read_file`: Reads a file within the project directory.
#  * `read_memory`: Reads the memory with the given name from Serena's project-specific memory store.
#  * `remove_project`: Removes a project from the Serena configuration.
#  * `replace_lines`: Replaces a range of lines within a file with new content.
#  * `replace_symbol_body`: Replaces the full definition of a symbol.
#  * `restart_language_server`: Restarts the language server, may be necessary when edits not through Serena happen.
#  * `search_for_pattern`: Performs a search for a pattern in the project.
#  * `summarize_changes`: Provides instructions for summarizing the changes made to the codebase.
#  * `switch_modes`: Activates modes by providing a list of their names
#  * `think_about_collected_information`: Thinking tool for pondering the completeness of collected information.
#  * `think_about_task_adherence`: Thinking tool for determining whether the agent is still on track with the current task.
#  * `think_about_whether_you_are_done`: Thinking tool for determining whether the task is truly completed.
#  * `write_memory`: Writes a named memory (for future reference) to Serena's project-specific memory store.
excluded_tools: []

# initial prompt for the project. It will always be given to the LLM upon activating the project
# (contrary to the memories, which are loaded on demand).
initial_prompt: |
  # InterviewApp - AI-Powered Interview Preparation Application

  ## Project Overview
  InterviewApp is an AI-powered interview preparation application built with Next.js 16, TypeScript, and Supabase. The application helps users practice behavioral interviews by submitting responses (text or audio) and receiving AI-generated feedback with scores across 7 behavioral competencies.

  ## Architecture & Patterns

  ### Onion Architecture (Clean Architecture)
  The codebase follows Onion Architecture with Domain-Driven Design principles:
  - **Domain Layer** (`src/domain/`): Core business logic, entities, value objects, domain services. Must remain pure and framework-independent.
  - **Application Layer** (`src/application/`): Use cases, DTOs, validation schemas, orchestration logic.
  - **Infrastructure Layer** (`src/infrastructure/`): External adapters (Supabase, PostHog, Redis, OpenAI, etc.), configuration, DI container.
  - **Presentation Layer** (`src/presentation/`, `src/app/`): Next.js App Router routes, API handlers, UI components.

  ### Feature Modules (Vertical Slices)
  Feature-specific code lives in `src/features/<feature>/` with its own domain/application/infrastructure/presentation layers:
  - `booking`: Content pack ingestion and validation
  - `scheduling`: Evaluation pipeline (LLM, ASR, transcript recovery)
  - `auth`: Authentication and entitlement policies
  - `billing`: Stripe webhook orchestration
  - `notifications`: Analytics and PostHog adapters

  ### Dependency Rules
  - Domain layer must NOT import from application/infrastructure/presentation
  - Feature modules may only import from other features through documented interfaces in `src/shared`
  - Use path aliases: `@domain/*`, `@app/*`, `@infra/*`, `@presentation/*`, `@shared/*`, `@features/*`
  - Boundary enforcement via Biome `noRestrictedImports` rules (`pnpm lint:boundaries`)

  ## Tech Stack

  - **Framework**: Next.js 16.0.7 (App Router, Turbopack)
  - **Language**: TypeScript 5.9+ (strict mode)
  - **Database**: Supabase (PostgreSQL)
  - **Auth**: Supabase Auth
  - **Analytics**: PostHog (with PII scrubbing)
  - **Monitoring**: Sentry
  - **Queue**: BullMQ with Redis (Upstash)
  - **AI**: OpenAI API
  - **Styling**: Tailwind CSS 4.x, Radix UI components
  - **Testing**: Vitest (unit/integration), Playwright (e2e)
  - **Linting/Formatting**: Biome
  - **Package Manager**: pnpm 10.x

  ## Key Patterns & Conventions

  ### Next.js 16+ Patterns
  - Route `params` and `searchParams` are Promises and MUST be awaited
  - Use `proxy.ts` instead of `middleware.ts` for global request handling
  - Server components by default, client components when needed

  ### Database & Types
  - Always use generated TypeScript types from `src/types/database.ts` (or `database.types.ts`)
  - Regenerate types after schema changes: `pnpm run update-types` or `pnpm run update-types:remote`
  - Use `Tables<"table_name">`, `TablesInsert<"table_name">`, `TablesUpdate<"table_name">` types
  - Never manually define interfaces that duplicate database structures

  ### Supabase Workflow
  - ALWAYS use Supabase CLI for migrations: `pnpm supabase migration new <name>`
  - NEVER manually create migration files
  - Regenerate types after applying migrations
  - Use typed clients from `src/lib/supabase/{client,server,proxy}.ts`

  ### Security & Compliance
  - All user input must be scrubbed for PHI (emails, phone numbers) before database save
  - PostHog events must pass through `DataScrubber` before sending
  - Sentry error contexts must be scrubbed
  - Use `src/shared/security/phi-scrubber.ts` and `data-scrubber.ts`

  ### Testing Requirements
  - Test-first development (TDD): Write tests → Get approval → Tests fail → Implement → Tests pass
  - Unit tests: `tests/unit/` (Vitest)
  - Integration tests: `tests/integration/` (Vitest)
  - E2E tests: `tests/e2e/` (Playwright)
  - Code coverage target: ≥80% for unit + integration tests
  - Tests must run without network, file system, or environment access (where applicable)

  ## Code Quality Standards

  ### Naming Conventions
  - Components: PascalCase, suffixed with 'Component' (e.g., `UserProfileComponent`)
  - Services: PascalCase, suffixed with 'Service' (e.g., `AuthService`)
  - Interfaces: PascalCase, prefixed with 'I' (e.g., `IUser`)
  - Variables/Functions: camelCase
  - Constants: UPPER_SNAKE_CASE

  ### TypeScript
  - Always include type annotations
  - Use interfaces for object shapes
  - Prefer `const` over `let`
  - Strict mode enabled

  ### Code Style
  - 2 spaces indentation
  - Use Biome for formatting and linting
  - JSDoc comments for all exported functions, services, and API endpoints
  - Comments required where they improve clarity (avoid redundant commentary)

  ### Commit & PR Standards
  - Conventional commit format: `<type>(<scope>): <description>`
  - Must pass `lefthook` hooks
  - Before PR: Submit proposal document
  - After PR: Provide implementation report

  ## Development Workflow

  ### Setup
  ```bash
  pnpm install
  pnpm prepare  # Install git hooks
  cp .env.example .env.local
  pnpm dev      # Start dev server (port 3000)
  ```

  ### Common Commands
  - `pnpm dev`: Start Next.js dev server
  - `pnpm dev:all`: Start app + worker concurrently
  - `pnpm build`: Build for production
  - `pnpm test`: Run all tests
  - `pnpm lint`: Run Biome linting
  - `pnpm lint:boundaries`: Check dependency boundaries
  - `pnpm typecheck`: TypeScript type checking
  - `pnpm update-types`: Regenerate database types

  ### MCP Integration
  - **Context7**: Use for library documentation and code generation
  - **Supabase**: Use MCP tools for database operations, migrations, type generation
  - **PostHog**: All events must be scrubbed via DataScrubber
  - **Sequential-Thinking**: Follow sequential workflow when marked in plans

  ## Important Notes

  - Always check existing memories (`supabase_workflow`, `nextjs-version-and-patterns`) before starting work
  - Follow the Constitution (`.specify/memory/constitution.md`) for all development decisions
  - Respect layer boundaries and feature module isolation
  - Keep domain logic pure and framework-independent
  - Ensure all code passes Biome checks and TypeScript strict mode
  - Maintain test coverage above 80% for unit + integration tests

project_name: "InterviewApp"
included_optional_tools: []
